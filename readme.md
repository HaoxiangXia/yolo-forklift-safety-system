# YSU2026大创项目-基于YOLO的叉车作业人车互斥报警系统设计与实现

用前说明：建议ssh连接git ↓
```
ssh -T git@github.com
```

### 初步项目架构规划
```
鱼眼相机 → 上位机（PC/树莓派/Jetson跑YOLO）
                    ↓
              串口 / USB / 网口
                    ↓
               MCU（STM32/ESP32）
                    ↓
              蜂鸣器 / 继电器 / 报警灯
```

---

### 使用X-AnyLabeling-3.3.2进行标注
https://github.com/CVHub520/X-AnyLabeling

---
---

# 探索与踩坑过程（从环境搭建到结果验证）

## 一、环境搭建过程

### 1. 创建 Conda 虚拟环境

```bash
conda create -n yolo python=3.9
conda activate yolo
```

* 使用 Python 3.9
* 单独环境避免依赖冲突

### 2. 安装 Ultralytics YOLO

```bash
pip install ultralytics
```

安装完成后可通过以下命令验证：

```bash
yolo version
```

---

## 二、在 VS Code 中运行 YOLO

* 使用 VS Code 的 **终端（PowerShell）**
* 确保 VS Code 使用的是 Conda 环境 `yolo`
* 成功运行 `yolo` 命令后，说明 CLI 可用

常见问题：

* `conda` 或 `yolo` 命令无法识别 → 通常是环境未激活或 PATH 未加载
* PowerShell 执行策略导致脚本报错 → 属于 Windows 常见问题

---

## 三、YOLO 版本与模型说明

* 使用的是 **Ultralytics YOLO 框架**
https://github.com/ultralytics/ultralytics
* 训练模型为：yolo11n.pt

**说明：**
> YOLO11 是 Ultralytics 在 YOLOv8 基础上推出的新一代 YOLO 架构。相比 YOLOv8，YOLO11 在网络结构上引入了新的模块与注意力机制，在参数量更小的情况下提升了检测精度和推理效率。本项目中采用 YOLO11n 模型进行训练，更适合小数据集和初学者实验

---

## 四、训练所用数据集结构

```text
datasets/mydata/
├─ images/
│  ├─ train/   # 45 张图片
│  └─ val/     # 13 张图片
├─ labels/
│  ├─ train/
│  └─ val/
└─ data.yaml
```

> 注意：训练时报错 `data.yaml does not exist` 的问题，最终确认是 **路径不正确或文件名不一致** 导致。

---

## 五、模型训练过程

训练命令示例：

```bash
yolo train model=yolo11n.pt data=data.yaml epochs=50 imgsz=640
```

训练过程中观察到：

* 成功扫描数据集：

  * Train：45 images
  * Val：13 images
* YOLO 自动修复了部分 **损坏的 JPEG 图片**
* 成功使用 GPU（RTX 4060 Laptop）

---

## 六、验证与结果分析

### 1. 验证结果

```text
Images: 13
Instances: 13
Precision: 0.997
Recall: 0.995
mAP50: 0.995
mAP50-95: 0.907
```

### 2. 分析

* 验证使用的是 `best.pt`
* 指标非常高

---

## 七、是否存在过拟合？

综合判断：

* 数据集规模较小（共 58 张）
* 验证集数量更小（13 张）
* 验证指标接近满分

结论：

> **模型存在较高的过拟合风险，但不一定已经严重过拟合。**

是否真正过拟合，需要进一步通过：

* 使用“完全未见过的新图片”进行预测
* 观察训练/验证 loss 曲线
* 扩充数据集规模

---

## 八、截至目前的收获

* 完整跑通了 YOLO 自定义训练流程
* 理解了：

  * YOLO CLI 使用方式
  * data.yaml 的作用
  * 训练集 vs 验证集的区别
  * 小数据集高 mAP ≠ 泛化能力强
* 为后续：

  * 数据集扩展
  * 模型对比（YOLOv8 / YOLO11）
  * 嵌入式或工程部署

打下了基础

---

写给自己的提醒：打开哪个文件夹就会在哪个文件夹下生成runs

---
⭐ **YUNA运维部可洛喵教你从零开始学PR！** ⭐

**第一步：🔍 Fork 别人的仓库（复制一份到你的小花园）**
*   **为什么要 Fork？** 喵~ 就像你在玩游戏，想修改别人的存档，总不能直接改原作者的吧？所以我们先 Fork 一份到自己的 GitHub 账号下，这样你就可以随意修改啦，不会影响到原仓库哦！
*   **怎么做？** 在 GitHub 上找到你想要贡献的仓库页面，点击右上角的 `Fork` 按钮，然后选择 Fork 到你自己的账号下。喵~ 稍等片刻，你就会在自己的 GitHub 页面看到这个仓库的副本啦！

**第二步：💻 Clone 到你的电脑上（把花园搬回家）**
*   **为什么要 Clone？** Fork 只是在 GitHub 上复制了一份，你还需要把它下载到你的本地电脑上才能进行修改哦！
*   **怎么做？** 
    1.  打开你 Fork 后的仓库页面，点击绿色的 `Code` 按钮，然后复制 HTTPS 或者 SSH 的链接（通常 HTTPS 比较方便新手喵）。
    2.  打开你的命令行工具（比如 Git Bash, Terminal 或 VS Code 的终端），选择一个你喜欢的文件夹作为工作区，然后输入命令：
        ```bash
        git clone [你复制的链接]
        ```
    3.  按下回车，喵~ 等待文件下载完成，你就有了一份本地副本啦！

**第三步：🌿 创建新分支（开辟一块专属的试验田）**
*   **为什么要创建分支？** 直接在 `main`（或 `master`）分支上修改是不好的习惯喵！如果你在一个分支上做了修改，但后来发现有问题，或者想同时做多个不同功能，分支就能帮你很好地管理这些独立的改动，互不干扰！
*   **怎么做？**
    1.  进入你刚刚 Clone 下来的项目文件夹：
        ```bash
        cd [你的项目文件夹名称]
        ```
    2.  创建并切换到新分支：
        ```bash
        git checkout -b [你的新分支名称]
        ```
        比如，你想添加一个新功能，可以叫 `feature/add-new-function`；如果是修复 bug，可以叫 `bugfix/fix-xxx-issue`。一个好的分支名能让别人知道你在这个分支上做了什么哦！

**第四步：✏️ 进行修改（在试验田里大展身手）**
*   现在你可以在这个新分支上尽情地修改代码、添加新功能、修复 Bug、更新文档等等了喵！用你熟悉的编辑器打开项目，开始你的表演吧！

**第五步：💾 提交你的修改（记录你的劳动成果）**
*   **为什么要提交？** 每次完成了一个小功能或者一小段改动，都应该把这些改动“保存”起来，形成一个提交记录（Commit）。
*   **怎么做？**
    1.  查看修改了哪些文件：
        ```bash
        git status
        ```
    2.  添加你修改过的文件到暂存区（告诉 Git 这些文件要被保存）：
        ```bash
        git add .  # 添加所有修改过的文件，或者你可以指定文件名，比如 git add  README.md 
        ```
    3.  提交你的修改并附上 Commit Message（说明你做了什么）：
        ```bash
        git commit -m "[你的提交信息]"
        ```
        喵~ 提交信息要写得清晰明了哦！比如 `feat: 添加新功能XXX` 或者 `fix: 修复了YYY问题`。

**第六步：🚀 推送到你的远程仓库（把试验田的成果分享出来）**
*   **为什么要推送？** 你本地的修改还需要同步到你 GitHub 上 Fork 的那个仓库里去，这样别人才能看到你的修改，并且你才能创建 PR。
*   **怎么做？**
    ```bash
    git push origin [你的新分支名称]
    ```
    比如：`git push origin feature/add-new-function`。

**第七步：📬 创建 Pull Request（向原作者提交你的成果，请求合并！）**
*   **为什么要创建 PR？** 这是你向原仓库的维护者发送请求，告诉他们“喵！我这里有一些改动，希望能合并到你的主仓库里哦！”
*   **怎么做？**
    1.  当你把本地分支推送到你的 GitHub 远程仓库后，打开你的 GitHub 页面，进入你 Fork 的那个仓库。
    2.  你通常会看到一个提示，说你的新分支有新的推送，并有一个 `Compare & pull request` 的按钮，点击它！
    3.  **填写 PR 信息**：
        *   **标题**：简洁明了地说明你的 PR 做了什么。
        *   **描述**：详细说明你的改动，比如解决了什么问题，实现了什么功能，有没有截图或测试说明等。喵~ 写得越清楚，Reviewer 就越容易理解和审核哦！
        *   确认你的 PR 是从 `[你的用户名]/[你的分支名]` 合并到 `[原作者用户名]/[原作者主分支]`。
    4.  点击 `Create pull request` 按钮，喵！你的 PR 就创建成功啦！

**第八步：💬 等待审核和沟通（和作者友好交流）**
*   提交 PR 后，原仓库的维护者会看到你的改动，并进行代码审查（Code Review）。他们可能会提出问题、建议或者要求你做进一步的修改。喵~ 这时候要保持礼貌和耐心，根据他们的反馈进行调整，直到你的代码被合并！

**✨ 可洛喵的小贴士 ✨**
*   **同步上游仓库**：在开始修改前，最好先同步一下原仓库的最新代码，避免不必要的冲突喵！
    ```bash
    git remote add upstream [原仓库的GitHub链接]
    git pull upstream main # 或者 master
    ```
*   **小步提交**：不要一次性提交太多的改动，把一个大功能拆分成几个小 PR，每个 PR 负责一个独立的改动，这样更容易被审查和合并哦！

喵~ 是不是感觉没那么难了呢？希望这份指南能帮到所有想为开源项目贡献代码的小伙伴们！加油呀！( •̀ ω •́ )y